{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/janidu/Documents/GitHub/NextGen-Builds/NextGen-Builds/frontend/src/app/components/DecryptedText.tsx"],"sourcesContent":["import { useEffect, useState, useRef, ReactNode } from 'react';\nimport { motion, HTMLMotionProps } from 'motion/react';\n\nconst styles = {\n  wrapper: {\n    display: 'inline-block',\n    whiteSpace: 'pre-wrap'\n  },\n  srOnly: {\n    position: 'absolute' as 'absolute',\n    width: '1px',\n    height: '1px',\n    padding: 0,\n    margin: '-1px',\n    overflow: 'hidden',\n    clip: 'rect(0,0,0,0)',\n    border: 0\n  }\n};\n\ninterface DecryptedTextProps extends HTMLMotionProps<'span'> {\n  text: string;\n  speed?: number;\n  maxIterations?: number;\n  sequential?: boolean;\n  revealDirection?: 'start' | 'end' | 'center';\n  useOriginalCharsOnly?: boolean;\n  characters?: string;\n  className?: string;\n  parentClassName?: string;\n  encryptedClassName?: string;\n  animateOn?: 'view' | 'hover' | 'both';\n}\n\nexport default function DecryptedText({\n  text,\n  speed = 50,\n  maxIterations = 10,\n  sequential = false,\n  revealDirection = 'start',\n  useOriginalCharsOnly = false,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',\n  className = '',\n  parentClassName = '',\n  encryptedClassName = '',\n  animateOn = 'hover',\n  ...props\n}: DecryptedTextProps) {\n  const [displayText, setDisplayText] = useState<string>(text);\n  const [isHovering, setIsHovering] = useState<boolean>(false);\n  const [isScrambling, setIsScrambling] = useState<boolean>(false);\n  const [revealedIndices, setRevealedIndices] = useState<Set<number>>(new Set());\n  const [hasAnimated, setHasAnimated] = useState<boolean>(false);\n  const containerRef = useRef<HTMLSpanElement>(null);\n\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    let currentIteration = 0;\n\n    const getNextIndex = (revealedSet: Set<number>): number => {\n      const textLength = text.length;\n      switch (revealDirection) {\n        case 'start':\n          return revealedSet.size;\n        case 'end':\n          return textLength - 1 - revealedSet.size;\n        case 'center': {\n          const middle = Math.floor(textLength / 2);\n          const offset = Math.floor(revealedSet.size / 2);\n          const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\n\n          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\n            return nextIndex;\n          }\n\n          for (let i = 0; i < textLength; i++) {\n            if (!revealedSet.has(i)) return i;\n          }\n          return 0;\n        }\n        default:\n          return revealedSet.size;\n      }\n    };\n\n    const availableChars = useOriginalCharsOnly\n      ? Array.from(new Set(text.split(''))).filter(char => char !== ' ')\n      : characters.split('');\n\n    const shuffleText = (originalText: string, currentRevealed: Set<number>): string => {\n      if (useOriginalCharsOnly) {\n        const positions = originalText.split('').map((char, i) => ({\n          char,\n          isSpace: char === ' ',\n          index: i,\n          isRevealed: currentRevealed.has(i)\n        }));\n\n        const nonSpaceChars = positions.filter(p => !p.isSpace && !p.isRevealed).map(p => p.char);\n\n        for (let i = nonSpaceChars.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\n        }\n\n        let charIndex = 0;\n        return positions\n          .map(p => {\n            if (p.isSpace) return ' ';\n            if (p.isRevealed) return originalText[p.index];\n            return nonSpaceChars[charIndex++];\n          })\n          .join('');\n      } else {\n        return originalText\n          .split('')\n          .map((char, i) => {\n            if (char === ' ') return ' ';\n            if (currentRevealed.has(i)) return originalText[i];\n            return availableChars[Math.floor(Math.random() * availableChars.length)];\n          })\n          .join('');\n      }\n    };\n\n    if (isHovering) {\n      setIsScrambling(true);\n      interval = setInterval(() => {\n        setRevealedIndices(prevRevealed => {\n          if (sequential) {\n            if (prevRevealed.size < text.length) {\n              const nextIndex = getNextIndex(prevRevealed);\n              const newRevealed = new Set(prevRevealed);\n              newRevealed.add(nextIndex);\n              setDisplayText(shuffleText(text, newRevealed));\n              return newRevealed;\n            } else {\n              clearInterval(interval);\n              setIsScrambling(false);\n              return prevRevealed;\n            }\n          } else {\n            setDisplayText(shuffleText(text, prevRevealed));\n            currentIteration++;\n            if (currentIteration >= maxIterations) {\n              clearInterval(interval);\n              setIsScrambling(false);\n              setDisplayText(text);\n            }\n            return prevRevealed;\n          }\n        });\n      }, speed);\n    } else {\n      setDisplayText(text);\n      setRevealedIndices(new Set());\n      setIsScrambling(false);\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\n\n  useEffect(() => {\n    if (animateOn !== 'view' && animateOn !== 'both') return;\n\n    const observerCallback = (entries: IntersectionObserverEntry[]) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting && !hasAnimated) {\n          setIsHovering(true);\n          setHasAnimated(true);\n        }\n      });\n    };\n\n    const observerOptions = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0.1\n    };\n\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [animateOn, hasAnimated]);\n\n  const hoverProps =\n    animateOn === 'hover' || animateOn === 'both'\n      ? {\n          onMouseEnter: () => setIsHovering(true),\n          onMouseLeave: () => setIsHovering(false)\n        }\n      : {};\n\n  return (\n    <motion.span className={parentClassName} ref={containerRef} style={styles.wrapper} {...hoverProps} {...props}>\n      <span style={styles.srOnly}>{displayText}</span>\n\n      <span aria-hidden=\"true\">\n        {displayText.split('').map((char, index) => {\n          const isRevealedOrDone = revealedIndices.has(index) || !isScrambling || !isHovering;\n\n          return (\n            <span key={index} className={isRevealedOrDone ? className : encryptedClassName}>\n              {char}\n            </span>\n          );\n        })}\n      </span>\n    </motion.span>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 260, "column": 0}, "map": {"version":3,"sources":["file:///home/janidu/Documents/GitHub/NextGen-Builds/NextGen-Builds/frontend/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { Box, Button, Typography } from '@mui/material';\nimport dynamic from 'next/dynamic';\nimport { motion } from 'framer-motion';\nimport DecryptedText from './components/DecryptedText';\n\n\n// Dynamically import SplineWrapper to avoid SSR issues\nconst SplineWrapper = dynamic(() => import('./components/SplineWrapper'), { ssr: false });\n\nexport default function LandingPage() {\n  return (\n    <Box\n      sx={{\n        position: 'relative',\n        width: '100%',\n        height: '100vh',\n        background: 'rgb(128, 128, 128)',\n        overflow: 'hidden',\n        border: '2px solid red', //tetsting\n      }}\n    >\n      {/* Fullscreen Spline animation */}\n      <Box\n        sx={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          zIndex: 0,\n        }}\n      >\n        <SplineWrapper />\n      </Box>\n\n      {/* Centered styled text */}\n     <Box\n  sx={{\n    position: 'absolute',\n    top: '50%',\n    left: '80%',\n    transform: 'translate(-50%, -50%)',\n    textAlign: 'center',\n    zIndex: 10,\n  }}\n>\n  <DecryptedText\n    text={`NextGen\\nBuilds`}\n    speed={80}\n    maxIterations={20}\n    characters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%\"\n    className=\"revealed\"\n    encryptedClassName=\"encrypted\"\n    animateOn=\"view\"\n    revealDirection=\"center\"\n\n    //  style={{\n    //   fontSize: 'clamp(2rem, 6vw, 5rem)',  // responsive size\n    //   fontWeight: 700,\n    //   color: '#222',                       // dark gray for white background\n    //   lineHeight: 1.1,\n    //   whiteSpace: 'pre-line',              // allows \\n to make new lines\n    // }}\n\n      style={{\n    fontSize: 'clamp(2rem, 6vw, 5rem)',\n    fontWeight: 800,\n    textTransform: 'uppercase',\n    background: 'linear-gradient(90deg, #ff6a00, #ee0979)',\n    WebkitBackgroundClip: 'text',\n    WebkitTextFillColor: 'transparent',\n    whiteSpace: 'pre-line',\n  }}\n\n  />\n\n \n</Box>\n      \n    </Box>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;;AALA;;;;;AAQA,uDAAuD;AACvD,MAAM,gBAAgB,IAAA,6KAAO,EAAC;;;;;;IAA8C,KAAK;;KAA3E;AAES,SAAS;IACtB,qBACE,6LAAC,kMAAG;QACF,IAAI;YACF,UAAU;YACV,OAAO;YACP,QAAQ;YACR,YAAY;YACZ,UAAU;YACV,QAAQ;QACV;;0BAGA,6LAAC,kMAAG;gBACF,IAAI;oBACF,UAAU;oBACV,KAAK;oBACL,MAAM;oBACN,OAAO;oBACP,QAAQ;oBACR,QAAQ;gBACV;0BAEA,cAAA,6LAAC;;;;;;;;;;0BAIJ,6LAAC,kMAAG;gBACP,IAAI;oBACF,UAAU;oBACV,KAAK;oBACL,MAAM;oBACN,WAAW;oBACX,WAAW;oBACX,QAAQ;gBACV;0BAEA,cAAA,6LAAC,wJAAa;oBACZ,MAAO;oBACP,OAAO;oBACP,eAAe;oBACf,YAAW;oBACX,WAAU;oBACV,oBAAmB;oBACnB,WAAU;oBACV,iBAAgB;oBAEhB,YAAY;oBACZ,4DAA4D;oBAC5D,qBAAqB;oBACrB,2EAA2E;oBAC3E,qBAAqB;oBACrB,wEAAwE;oBACxE,KAAK;oBAEH,OAAO;wBACT,UAAU;wBACV,YAAY;wBACZ,eAAe;wBACf,YAAY;wBACZ,sBAAsB;wBACtB,qBAAqB;wBACrB,YAAY;oBACd;;;;;;;;;;;;;;;;;AASF;MAxEwB","debugId":null}}]
}