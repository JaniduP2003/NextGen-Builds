{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/janidu/Documents/GitHub/NextGen-Builds/NextGen-Builds/frontend/src/app/components/DecryptedText.tsx"],"sourcesContent":["import { useEffect, useState, useRef, ReactNode } from 'react';\nimport { motion, HTMLMotionProps } from 'motion/react';\n\nconst styles = {\n  wrapper: {\n    display: 'inline-block',\n    whiteSpace: 'pre-wrap'\n  },\n  srOnly: {\n    position: 'absolute' as 'absolute',\n    width: '1px',\n    height: '1px',\n    padding: 0,\n    margin: '-1px',\n    overflow: 'hidden',\n    clip: 'rect(0,0,0,0)',\n    border: 0\n  }\n};\n\ninterface DecryptedTextProps extends HTMLMotionProps<'span'> {\n  text: string;\n  speed?: number;\n  maxIterations?: number;\n  sequential?: boolean;\n  revealDirection?: 'start' | 'end' | 'center';\n  useOriginalCharsOnly?: boolean;\n  characters?: string;\n  className?: string;\n  parentClassName?: string;\n  encryptedClassName?: string;\n  animateOn?: 'view' | 'hover' | 'both';\n}\n\nexport default function DecryptedText({\n  text,\n  speed = 50,\n  maxIterations = 10,\n  sequential = false,\n  revealDirection = 'start',\n  useOriginalCharsOnly = false,\n  characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz!@#$%^&*()_+',\n  className = '',\n  parentClassName = '',\n  encryptedClassName = '',\n  animateOn = 'hover',\n  ...props\n}: DecryptedTextProps) {\n  const [displayText, setDisplayText] = useState<string>(text);\n  const [isHovering, setIsHovering] = useState<boolean>(false);\n  const [isScrambling, setIsScrambling] = useState<boolean>(false);\n  const [revealedIndices, setRevealedIndices] = useState<Set<number>>(new Set());\n  const [hasAnimated, setHasAnimated] = useState<boolean>(false);\n  const containerRef = useRef<HTMLSpanElement>(null);\n\n  useEffect(() => {\n    let interval: NodeJS.Timeout;\n    let currentIteration = 0;\n\n    const getNextIndex = (revealedSet: Set<number>): number => {\n      const textLength = text.length;\n      switch (revealDirection) {\n        case 'start':\n          return revealedSet.size;\n        case 'end':\n          return textLength - 1 - revealedSet.size;\n        case 'center': {\n          const middle = Math.floor(textLength / 2);\n          const offset = Math.floor(revealedSet.size / 2);\n          const nextIndex = revealedSet.size % 2 === 0 ? middle + offset : middle - offset - 1;\n\n          if (nextIndex >= 0 && nextIndex < textLength && !revealedSet.has(nextIndex)) {\n            return nextIndex;\n          }\n\n          for (let i = 0; i < textLength; i++) {\n            if (!revealedSet.has(i)) return i;\n          }\n          return 0;\n        }\n        default:\n          return revealedSet.size;\n      }\n    };\n\n    const availableChars = useOriginalCharsOnly\n      ? Array.from(new Set(text.split(''))).filter(char => char !== ' ')\n      : characters.split('');\n\n    const shuffleText = (originalText: string, currentRevealed: Set<number>): string => {\n      if (useOriginalCharsOnly) {\n        const positions = originalText.split('').map((char, i) => ({\n          char,\n          isSpace: char === ' ',\n          index: i,\n          isRevealed: currentRevealed.has(i)\n        }));\n\n        const nonSpaceChars = positions.filter(p => !p.isSpace && !p.isRevealed).map(p => p.char);\n\n        for (let i = nonSpaceChars.length - 1; i > 0; i--) {\n          const j = Math.floor(Math.random() * (i + 1));\n          [nonSpaceChars[i], nonSpaceChars[j]] = [nonSpaceChars[j], nonSpaceChars[i]];\n        }\n\n        let charIndex = 0;\n        return positions\n          .map(p => {\n            if (p.isSpace) return ' ';\n            if (p.isRevealed) return originalText[p.index];\n            return nonSpaceChars[charIndex++];\n          })\n          .join('');\n      } else {\n        return originalText\n          .split('')\n          .map((char, i) => {\n            if (char === ' ') return ' ';\n            if (currentRevealed.has(i)) return originalText[i];\n            return availableChars[Math.floor(Math.random() * availableChars.length)];\n          })\n          .join('');\n      }\n    };\n\n    if (isHovering) {\n      setIsScrambling(true);\n      interval = setInterval(() => {\n        setRevealedIndices(prevRevealed => {\n          if (sequential) {\n            if (prevRevealed.size < text.length) {\n              const nextIndex = getNextIndex(prevRevealed);\n              const newRevealed = new Set(prevRevealed);\n              newRevealed.add(nextIndex);\n              setDisplayText(shuffleText(text, newRevealed));\n              return newRevealed;\n            } else {\n              clearInterval(interval);\n              setIsScrambling(false);\n              return prevRevealed;\n            }\n          } else {\n            setDisplayText(shuffleText(text, prevRevealed));\n            currentIteration++;\n            if (currentIteration >= maxIterations) {\n              clearInterval(interval);\n              setIsScrambling(false);\n              setDisplayText(text);\n            }\n            return prevRevealed;\n          }\n        });\n      }, speed);\n    } else {\n      setDisplayText(text);\n      setRevealedIndices(new Set());\n      setIsScrambling(false);\n    }\n\n    return () => {\n      if (interval) clearInterval(interval);\n    };\n  }, [isHovering, text, speed, maxIterations, sequential, revealDirection, characters, useOriginalCharsOnly]);\n\n  useEffect(() => {\n    if (animateOn !== 'view' && animateOn !== 'both') return;\n\n    const observerCallback = (entries: IntersectionObserverEntry[]) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting && !hasAnimated) {\n          setIsHovering(true);\n          setHasAnimated(true);\n        }\n      });\n    };\n\n    const observerOptions = {\n      root: null,\n      rootMargin: '0px',\n      threshold: 0.1\n    };\n\n    const observer = new IntersectionObserver(observerCallback, observerOptions);\n    const currentRef = containerRef.current;\n    if (currentRef) {\n      observer.observe(currentRef);\n    }\n\n    return () => {\n      if (currentRef) {\n        observer.unobserve(currentRef);\n      }\n    };\n  }, [animateOn, hasAnimated]);\n\n  const hoverProps =\n    animateOn === 'hover' || animateOn === 'both'\n      ? {\n          onMouseEnter: () => setIsHovering(true),\n          onMouseLeave: () => setIsHovering(false)\n        }\n      : {};\n\n  return (\n    <motion.span className={parentClassName} ref={containerRef} style={styles.wrapper} {...hoverProps} {...props}>\n      <span style={styles.srOnly}>{displayText}</span>\n\n      <span aria-hidden=\"true\">\n        {displayText.split('').map((char, index) => {\n          const isRevealedOrDone = revealedIndices.has(index) || !isScrambling || !isHovering;\n\n          return (\n            <span key={index} className={isRevealedOrDone ? className : encryptedClassName}>\n              {char}\n            </span>\n          );\n        })}\n      </span>\n    </motion.span>\n  );\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///home/janidu/Documents/GitHub/NextGen-Builds/NextGen-Builds/frontend/src/app/page.tsx"],"sourcesContent":["'use client';\n\nimport { Box, Button, Typography } from '@mui/material';\nimport dynamic from 'next/dynamic';\nimport { motion } from 'framer-motion';\nimport DecryptedText from './components/DecryptedText';\n\n\n// Dynamically import SplineWrapper to avoid SSR issues\nconst SplineWrapper = dynamic(() => import('./components/SplineWrapper'), { ssr: false });\n\nexport default function LandingPage() {\n  return (\n    <Box\n      sx={{\n        position: 'relative',\n        width: '100%',\n        height: '100vh',\n        background: 'rgb(128, 128, 128)',\n        overflow: 'hidden',\n        border: '2px solid red', //tetsting\n      }}\n    >\n      {/* Fullscreen Spline animation */}\n      <Box\n        sx={{\n          position: 'absolute',\n          top: 0,\n          left: 0,\n          width: '100%',\n          height: '100%',\n          zIndex: 0,\n        }}\n      >\n        <SplineWrapper />\n      </Box>\n\n      {/* Centered styled text */}\n     <Box\n  sx={{\n    position: 'absolute',\n    top: '50%',\n    left: '80%',\n    transform: 'translate(-50%, -50%)',\n    textAlign: 'center',\n    zIndex: 10,\n  }}\n>\n  <DecryptedText\n    text=\"NextGen Builds\"\n    speed={80}\n    maxIterations={20}\n    characters=\"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%\"\n    className=\"revealed\"\n    encryptedClassName=\"encrypted\"\n    animateOn=\"view\"\n    revealDirection=\"center\"\n  />\n\n \n</Box>\n      \n    </Box>\n  );\n}\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;;AALA;;;;;AAQA,uDAAuD;AACvD,MAAM,gBAAgB,IAAA,0KAAO;;;;;;IAA+C,KAAK;;AAElE,SAAS;IACtB,qBACE,8OAAC,+LAAG;QACF,IAAI;YACF,UAAU;YACV,OAAO;YACP,QAAQ;YACR,YAAY;YACZ,UAAU;YACV,QAAQ;QACV;;0BAGA,8OAAC,+LAAG;gBACF,IAAI;oBACF,UAAU;oBACV,KAAK;oBACL,MAAM;oBACN,OAAO;oBACP,QAAQ;oBACR,QAAQ;gBACV;0BAEA,cAAA,8OAAC;;;;;;;;;;0BAIJ,8OAAC,+LAAG;gBACP,IAAI;oBACF,UAAU;oBACV,KAAK;oBACL,MAAM;oBACN,WAAW;oBACX,WAAW;oBACX,QAAQ;gBACV;0BAEA,cAAA,8OAAC,qJAAa;oBACZ,MAAK;oBACL,OAAO;oBACP,eAAe;oBACf,YAAW;oBACX,WAAU;oBACV,oBAAmB;oBACnB,WAAU;oBACV,iBAAgB;;;;;;;;;;;;;;;;;AAQpB","debugId":null}}]
}